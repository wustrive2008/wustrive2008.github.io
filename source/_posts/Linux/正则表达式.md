title: 正则表达式
date: 2016-3-21 16:00:05
categories: Linux
tags: [linux,regex,正则表达式]
---

正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。
<!--more-->

### 基础语法

```
------------------------------------------------------------------------------
字符         | 说明
------------------------------------------------------------------------------
\            | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符
------------------------------------------------------------------------------
^            | 匹配输入字符串开始的位置
------------------------------------------------------------------------------
$            | 匹配输入字符串结束的位置
------------------------------------------------------------------------------
*            | 零次或多次匹配前面的字符或子表达式
------------------------------------------------------------------------------
+            | 一次或多次匹配前面的字符或子表达式
------------------------------------------------------------------------------
?            | 零次或一次匹配前面的字符或子表达式
------------------------------------------------------------------------------
{n}          | n 是非负整数。正好匹配 n 次
------------------------------------------------------------------------------
{n,}         | 至少匹配 n 次
------------------------------------------------------------------------------
{n,m}        | 匹配至少 n 次，至多 m 次
------------------------------------------------------------------------------
?            | 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）
              之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、
              尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串
------------------------------------------------------------------------------
.            | 匹配除"\r\n"之外的任何单个字符
------------------------------------------------------------------------------
(pattern)    | 匹配 pattern 并捕获该匹配的子表达式
------------------------------------------------------------------------------
(?:pattern)  | 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，
              不存储供以后使用的匹配
------------------------------------------------------------------------------
(?=pattern)  | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 
              pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配
------------------------------------------------------------------------------
(?!pattern)  | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 
              pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配
------------------------------------------------------------------------------
x|y          | 匹配 x 或 y
------------------------------------------------------------------------------
[xyz]        | 字符集。匹配包含的任一字符
------------------------------------------------------------------------------
[^xyz]       | 反向字符集。匹配未包含的任何字符
------------------------------------------------------------------------------
[a-z]        | 字符范围。匹配指定范围内的任何字符
------------------------------------------------------------------------------
[^a-z]       | 反向范围字符。匹配不在指定的范围内的任何字符
------------------------------------------------------------------------------
\b           | 匹配一个字边界，即字与空格间的位置。
------------------------------------------------------------------------------
\B           | 非字边界匹配。
------------------------------------------------------------------------------
\cx          | 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。
              x 的值必须在 A-Z 或 a-z 之间
------------------------------------------------------------------------------
\d           | 数字字符匹配。等效于 [0-9]。
------------------------------------------------------------------------------
\D           | 非数字字符匹配。等效于 [^0-9]。
------------------------------------------------------------------------------
\f           | 换页符匹配。等效于 \x0c 和 \cL。
------------------------------------------------------------------------------
\n           | 换行符匹配。等效于 \x0a 和 \cJ。
------------------------------------------------------------------------------
\r           | 匹配一个回车符。等效于 \x0d 和 \cM。
------------------------------------------------------------------------------
\s           | 匹配任何空白字符，包括空格、制表符、换页符等。
------------------------------------------------------------------------------
\S           | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。
------------------------------------------------------------------------------
\t           | 制表符匹配。与 \x09 和 \cI 等效。
------------------------------------------------------------------------------
\v           | 垂直制表符匹配。与 \x0b 和 \cK 等效。
------------------------------------------------------------------------------
\w           | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效
------------------------------------------------------------------------------
\W           | 与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。
------------------------------------------------------------------------------
\xn          | 匹配 n，此处的 n 是一个十六进制转义码。
              十六进制转义码必须正好是两位数长
------------------------------------------------------------------------------
\num         | 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用
------------------------------------------------------------------------------
\n           | 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个
              捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。
------------------------------------------------------------------------------
\nm          | 标识一个八进制转义码或反向引用。
------------------------------------------------------------------------------
\nml         | 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，
              匹配八进制转义码 nml。
------------------------------------------------------------------------------
\un          | 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。
              例如，\u00A9 匹配版权符号 (©)。
------------------------------------------------------------------------------
```


### 常用正则表达式

```
用户名：/^[a-z0-9_-]{3,16}$/
密码：/^[a-z0-9_-]{6,18}$/
十六进制值：/^#?([a-f0-9]{6}|[a-f0-9]{3})$/
电子邮箱：/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/
URL：/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/
IP 地址：/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
HTML 标签：/^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$/
Unicode编码中的汉字范围：/^[u4e00-u9fa5],{0,}$/
匹配中文字符的正则表达式： [\u4e00-\u9fa5]
评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^\x00-\xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：\n\s*\r
评注：可以用来删除空白行
匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
匹配首尾空白字符的正则表达式：^\s*|\s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
评注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用
匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}
评注：匹配形式如 0511-4405222 或 021-87888822
匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10000开始
匹配中国大陆邮政编码：[1-9]\d{5}(?!\d)
评注：中国大陆邮政编码为6位数字
匹配身份证：\d{15}|\d{18}
评注：中国大陆的身份证为15位或18位
匹配ip地址：\d+\.\d+\.\d+\.\d+
评注：提取ip地址时有用
匹配特定数字：
^[1-9]\d*$　 　 //匹配正整数
^-[1-9]\d*$ 　 //匹配负整数
^-?[1-9]\d*$　　 //匹配整数
^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数
^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数
^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
评注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串：
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串

```


### 分组捕获 "()"

#### 分组

用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。
默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。
示例：
(\d{1,3}\.){3}\d{1,3}  是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})

#### 反向引用

后向引用用于重复搜索前面某个分组匹配的文本,示例:
\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)

#### 自定义组名

你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。

常用的分组语法
```
分类        代码/语法              说明
-------------------------------------------------------------------------------
捕获        (exp)                  匹配exp,并捕获文本到自动命名的组里
-------------------------------------------------------------------------------
            (?<name>exp)           匹配exp,并捕获文本到名称为name的组里，
                                   也可以写成(?'name'exp)   
-------------------------------------------------------------------------------
            (?:exp)                匹配exp,不捕获匹配的文本，也不给此分组分配
                                   组号
-------------------------------------------------------------------------------
零宽断言    (?=exp)                匹配exp前面的位置
-------------------------------------------------------------------------------
            (?<=exp)               匹配exp后面的位置
-------------------------------------------------------------------------------
            (?!exp)                匹配后面跟的不是exp的位置
-------------------------------------------------------------------------------
            (?<!exp)               匹配前面不是exp的位置
```


### 零宽断言

#### 零宽断言

```
(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。
(?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
```

#### 负向零宽断言

```
\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。
零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。
同理，我们可以用
(?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字
```

### 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：
a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）


### 正则表达式编写建议

#### 常见问题

误匹配：指正则表达式所匹配的内容范围超出了所需要范围，有些文本明明不符合要求，但是被所写的正则式“击中了”。例如，如果使用\d{11}来匹配11位的手机号，\d{11}不单能匹配正确的手机号，它还会匹配98765432100这样的明显不是手机号的字符串。我们把这样的匹配称之为误匹配。
漏匹配：指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则没有将这种情况囊括在内。例如，使用\d{18}来匹配18位的身份证号码，就会漏掉结尾是字母X的情况。

写出一条正则表达式，既可能只出现误匹配（条件写得极宽松，其范围大于目标文本），也可能只出现漏匹配（只描述了目标文本中多种情况种的一种），还可能既有误匹配又有漏匹配。例如，使用\w+\.com来匹配.com结尾的域名，既会误匹配abc_.com这样的字串（合法的域名中不含下划线，\w包含了下划线这种情况），又会漏掉ab-c.com这样的域名（合法域名中可以含中划线，但是\w不匹配中划线）。

####  编写建议

* 掌握语法细节。正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_]；perl正则式不支持肯定逆序环视中使用可变的重复（variable repetition inside lookbehind，例如(?<=.*)abc），但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视（Lookbehind,如(?<=ab)c）都不支持，而perl和python是支持的。《精通正则表达式》第3章《正则表达式的特性和流派概览》明确地列出了各大派系正则的异同，这篇文章也简要地列出了几种常用语言、工具中正则的比较。对于具体使用者而言，至少应该详细了解正在使用的那种工作语言里正则的语法细节。

* 先粗后精，先加后减。使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，再逐步在局步实现细节。仍举刚才的手机号的例子，先界定\d{11}，总不会错；再细化为1[358]\d{9}，就向前迈了一大步（至于第二位是不是3、5、8，这里无意深究，只举这样一个例子，说明逐步细化的过程）。这样做的目的是先消除漏匹配（刚开始先尽可能多地匹配，做加法），然后再一点一点地消除误匹配（做减法）。这样有先有后，在考虑时才不易出错，从而向“不误不漏”这个目标迈进。

* 留有余地。所能看到的文本sample是有限的，而待匹配检验的文本是海量的，暂时不可见的。对于这样的情况，在写正则表达式时要跳出所能见到的文本的圈子，开拓思路，作出“战略性前瞻”。例如，经常收到这样的垃圾短信：“发*票”、“发#漂”。如果要写规则屏蔽这样烦人的垃圾短信，不但要能写出可以匹配当前文本的正则表达式 发[*#](?:票|漂)，还要能够想到 发.(?:票|漂|飘)之类可能出现的“变种”。这在具体的领域或许会有针对性的规则，不多言。这样做的目的是消除漏匹配，延长正则表达式的生命周期。

* 明确。具体说来，就是谨慎用点号这样的元字符，尽可能不用星号和加号这样的任意量词。只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。例如，写析取twitter消息的脚本，假设一条消息的xml正文部分结构是<span class=”msg”>…</span>且正文中无尖括号，那么<span class=”msg”>[^<]{1,480}</span>这种写法的思路要好于<span class=”msg”>.*</span>，原因有二：一是使用[^<]，它保证了文本的范围不会超出下一个小于号所在的位置；二是明确长度范围，{1,480}，其依据是一条twitter消息大致能的字符长度范围。当然，480这个长度是否正确还可推敲，但是这种思路是值得借鉴的。说得狠一点，“滥用点号、星号和加号是不环保、不负责任的做法”。

* 不要让稻草压死骆驼。每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。这样的正则表达式、无限次地运行次数，无异于一根根稻草的堆加，终于能将骆驼压死。养成合理使用(?:…)括号的习惯。

* 宁简勿繁。将一条复杂的正则表达式拆分为两条或多条简单的正则表达式，编程难度会降低，运行效率会提升。例如用来消除行首和行尾空白字符的正则表达式s/^\s+|\s+$//g;，其运行效率理论上要低于s/^\s+//g; s/\s+$//g; 。这个例子出自《精通正则表达式》第五章，书中对它的评论是“它几乎总是最快的，而且显然最容易理解”。既快又容易理解，何乐而不为？工作中我们还有其它的理由要将C==(A|B)这样的正则表达式拆为A和B两条表达式分别执行。例如，虽然A和B这两种情况只要有一种能够击中所需要的文本模式就会成功匹配，但是如果只要有一条子表达式（例如A）会产生误匹配，那么不论其它的子表达式（例如B）效率如何之高，范围如何精准，C的总体精准度也会因A而受到影响。

* 巧妙定位。有时候，我们需要匹配的the，是作为单词的the（两边有空格），而不是作为单词一部分的t-h-e的有序排列（例如together中的the）。在适当的时候用上^，$，\b等等定位锚点，能有效提升找到成功匹配、淘汰不成功匹配的效率。

### 参考博文
1. [正则表达式30分钟入门教程](http://www.jb51.net/tools/zhengze.html)
2. [常用正则表达式](http://www.jb51.net/tools/regex.htm)

